# # tokenizer
# from tqdm import tqdm
# from transformers import RobertaTokenizer
#
# from bintools.general.file_tool import load_from_json_file
# from main.interface import DataItemForFunctionConfirmModel
# model_name = 'microsoft/graphcodebert-base'
# tokenizer = RobertaTokenizer.from_pretrained(model_name)
# for special_token in DataItemForFunctionConfirmModel.get_special_tokens():
#     tokenizer.add_tokens(special_token)
#
# train_data_json = load_from_json_file("TestCases/model_train/model_1/train_data/train_data.json")
# data_items = []
# for item in train_data_json:
#     data_item = DataItemForFunctionConfirmModel.init_from_dict(item)
#     data_item.normalize()
#     data_items.append(data_item)
#
#
# for data_item in tqdm(data_items):
#     text = data_item.get_train_text(tokenizer.sep_token)
#     encoding = tokenizer.encode_plus(
#         text,
#         add_special_tokens=True,
#         # max_length=512,
#         # padding='max_length',
#         # truncation=True,
#         return_attention_mask=True,
#         return_tensors='pt',
#     )
#     # 输出token长度
#     token_length = len(encoding['input_ids'][0])
#     if token_length>512:
#         print(token_length)

json_data = {
        "id": 121,
        "function_name": "ssl_update_cache",
        "src_codes": [
            "void ssl_update_cache(SSL_CONNECTION *s, int mode)",
            "{",
            "    int i;",
            "",
            "    /*",
            "     * If the session_id_length is 0, we are not supposed to cache it, and it",
            "     * would be rather hard to do anyway :-)",
            "     */",
            "    if (s->session->session_id_length == 0)",
            "        return;",
            "",
            "    /*",
            "     * If sid_ctx_length is 0 there is no specific application context",
            "     * associated with this session, so when we try to resume it and",
            "     * SSL_VERIFY_PEER is requested to verify the client identity, we have no",
            "     * indication that this is actually a session for the proper application",
            "     * context, and the *handshake* will fail, not just the resumption attempt.",
            "     * Do not cache (on the server) these sessions that are not resumable",
            "     * (clients can set SSL_VERIFY_PEER without needing a sid_ctx set).",
            "     */",
            "    if (s->server && s->session->sid_ctx_length == 0",
            "            && (s->verify_mode & SSL_VERIFY_PEER) != 0)",
            "        return;",
            "",
            "    i = s->session_ctx->session_cache_mode;",
            "    if ((i & mode) != 0",
            "        && (!s->hit || SSL_CONNECTION_IS_TLS13(s))) {",
            "        /*",
            "         * Add the session to the internal cache. In server side TLSv1.3 we",
            "         * normally don't do this because by default it's a full stateless ticket",
            "         * with only a dummy session id so there is no reason to cache it,",
            "         * unless:",
            "         * - we are doing early_data, in which case we cache so that we can",
            "         *   detect replays",
            "         * - the application has set a remove_session_cb so needs to know about",
            "         *   session timeout events",
            "         * - SSL_OP_NO_TICKET is set in which case it is a stateful ticket",
            "         */",
            "        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0",
            "                && (!SSL_CONNECTION_IS_TLS13(s)",
            "                    || !s->server",
            "                    || (s->max_early_data > 0",
            "                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)",
            "                    || s->session_ctx->remove_session_cb != NULL",
            "                    || (s->options & SSL_OP_NO_TICKET) != 0))",
            "            SSL_CTX_add_session(s->session_ctx, s->session);",
            "",
            "        /*",
            "         * Add the session to the external cache. We do this even in server side",
            "         * TLSv1.3 without early data because some applications just want to",
            "         * know about the creation of a session and aren't doing a full cache.",
            "         */",
            "        if (s->session_ctx->new_session_cb != NULL) {",
            "            SSL_SESSION_up_ref(s->session);",
            "            if (!s->session_ctx->new_session_cb(SSL_CONNECTION_GET_SSL(s),",
            "                                                s->session))",
            "                SSL_SESSION_free(s->session);",
            "        }",
            "    }",
            "",
            "    /* auto flush every 255 connections */",
            "    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {",
            "        TSAN_QUALIFIER int *stat;",
            "",
            "        if (mode & SSL_SESS_CACHE_CLIENT)",
            "            stat = &s->session_ctx->stats.sess_connect_good;",
            "        else",
            "            stat = &s->session_ctx->stats.sess_accept_good;",
            "        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)",
            "            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));",
            "    }",
            "}"
        ],
        "src_strings": [],
        "src_numbers": [
            "0xff",
            "0"
        ],
        "asm_codes": [
            "endbr64",
            "push    rbp",
            "mov     rbp, rsp",
            "sub     rsp, 20h",
            "mov     [rbp+s], rdi",
            "mov     [rbp+mode], esi",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+880h]",
            "mov     rax, [rax+250h]",
            "test    rax, rax",
            "jz      loc_4B9EF",
            "mov     rax, [rbp+s]",
            "mov     eax, [rax+70h]",
            "test    eax, eax",
            "jz      short loc_4B7B8",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+880h]",
            "mov     rax, [rax+278h]",
            "test    rax, rax",
            "jnz     short loc_4B7B8",
            "mov     rax, [rbp+s]",
            "mov     eax, [rax+8D0h]",
            "and     eax, 1",
            "test    eax, eax",
            "jnz     loc_4B9F2",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     eax, [rax+50h]",
            "mov     [rbp+i], eax",
            "mov     eax, [rbp+i]",
            "and     eax, [rbp+mode]",
            "test    eax, eax",
            "jz      loc_4B953",
            "mov     rax, [rbp+s]",
            "mov     eax, [rax+488h]",
            "test    eax, eax",
            "jz      short loc_4B82C",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+18h]",
            "mov     rax, [rax+0D8h]",
            "mov     eax, [rax+50h]",
            "and     eax, 8",
            "test    eax, eax",
            "jnz     loc_4B953",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+18h]",
            "mov     eax, [rax]",
            "cmp     eax, 303h",
            "jle     loc_4B953",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+18h]",
            "mov     eax, [rax]",
            "cmp     eax, offset stru_10000",
            "jz      loc_4B953",
            "mov     eax, [rbp+i]",
            "and     eax, 200h",
            "test    eax, eax",
            "jnz     loc_4B8EF",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+18h]",
            "mov     rax, [rax+0D8h]",
            "mov     eax, [rax+50h]",
            "and     eax, 8",
            "test    eax, eax",
            "jnz     short loc_4B8CE",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+18h]",
            "mov     eax, [rax]",
            "cmp     eax, 303h",
            "jle     short loc_4B8CE",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+18h]",
            "mov     eax, [rax]",
            "cmp     eax, offset stru_10000",
            "jz      short loc_4B8CE",
            "mov     rax, [rbp+s]",
            "mov     eax, [rax+70h]",
            "test    eax, eax",
            "jz      short loc_4B8CE",
            "mov     rax, [rbp+s]",
            "mov     eax, [rax+14A0h]",
            "test    eax, eax",
            "jz      short loc_4B8A5",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+930h]",
            "and     eax, 1000000h",
            "test    rax, rax",
            "jz      short loc_4B8CE",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     rax, [rax+68h]",
            "test    rax, rax",
            "jnz     short loc_4B8CE",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+930h]",
            "and     eax, 4000h",
            "test    rax, rax",
            "jz      short loc_4B8EF",
            "mov     rax, [rbp+s]",
            "mov     rdx, [rax+880h]",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     rsi, rdx; c",
            "mov     rdi, rax; ctx",
            "call    SSL_CTX_add_session",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     rax, [rax+60h]",
            "test    rax, rax",
            "jz      short loc_4B953",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+880h]",
            "mov     rdi, rax; ss_0",
            "call    SSL_SESSION_up_ref",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     rcx, [rax+60h]",
            "mov     rax, [rbp+s]",
            "mov     rdx, [rax+880h]",
            "mov     rax, [rbp+s]",
            "mov     rsi, rdx",
            "mov     rdi, rax",
            "call    rcx",
            "test    eax, eax",
            "jnz     short loc_4B953",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+880h]",
            "mov     rdi, rax; ss_0",
            "call    SSL_SESSION_free",
            "mov     eax, [rbp+i]",
            "and     eax, 80h",
            "test    eax, eax",
            "jnz     locret_4B9F3",
            "mov     eax, [rbp+i]",
            "and     eax, [rbp+mode]",
            "cmp     [rbp+mode], eax",
            "jnz     locret_4B9F3",
            "mov     eax, [rbp+mode]",
            "and     eax, 1",
            "test    eax, eax",
            "jz      short loc_4B991",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "sub     rax, 0FFFFFFFFFFFFFF80h",
            "mov     [rbp+stat], rax",
            "jmp     short loc_4B9A6",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "add     rax, 8Ch",
            "mov     [rbp+stat], rax",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     rdx, [rbp+stat]",
            "mov     rsi, rdx; stat",
            "mov     rdi, rax; ctx",
            "call    ssl_tsan_load",
            "movzx   eax, al",
            "cmp     eax, 0FFh",
            "jnz     short locret_4B9F3",
            "mov     edi, 0; timer",
            "call    _time",
            "mov     rdx, rax",
            "mov     rax, [rbp+s]",
            "mov     rax, [rax+0AE8h]",
            "mov     rsi, rdx; t",
            "mov     rdi, rax; s",
            "call    SSL_CTX_flush_sessions",
            "jmp     short locret_4B9F3",
            "nop",
            "jmp     short locret_4B9F3",
            "nop",
            "leave",
            "retn"
        ],
        "bin_strings": [
            "H"
        ],
        "bin_numbers": [
            "32",
            "1",
            "65536",
            "771",
            "512",
            "16777216",
            "16384",
            "128",
            "8",
            "18446744073709551488",
            "0",
            "140",
            "255"
        ],
        "label": 1
    }
from main.interface import DataItemForFunctionConfirmModel

demo = DataItemForFunctionConfirmModel.init_from_dict(json_data)
demo.normalize()
print(demo.get_train_text())